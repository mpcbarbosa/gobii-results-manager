import { NextResponse } from "next/server";
import { requireAdminAuth } from "@/lib/adminAuth";
import prisma from "@/lib/prisma";
import { LeadStatus } from "@prisma/client";
import {
  deriveCommercialSignal,
  type ActivityInput,
} from "@/lib/crm/deriveCommercialSignal";
import { deriveLeadTemperature } from "@/lib/crm/deriveLeadTemperature";
import { deriveHumanSLA } from "@/lib/crm/deriveHumanSLA";

const TERMINAL_STATUSES: LeadStatus[] = [
  LeadStatus.WON,
  LeadStatus.LOST,
  LeadStatus.DISCARDED,
];

const TEMP_ORDER: Record<string, number> = { HOT: 0, WARM: 1, COLD: 2 };
const SLA_ORDER: Record<string, number> = { OVERDUE: 0, WARNING: 1, OK: 2 };

interface NextTaskInfo {
  id: string;
  title: string;
  dueAt: string | null;
  createdAt: string;
  autoGenerated: boolean;
  metaCategory: string | null;
  metaConfidence: string | null;
}

/**
 * GET /api/admin/leads/work-queue
 *
 * Prioritised list of non-terminal leads with signal, temperature, SLA, and tasks.
 * Query params:
 *   ?ownerId=<uuid>  — filter by owner
 *   ?sort=temperature|sla|taskDue  — sort mode (default: temperature)
 */
export async function GET(request: Request) {
  const auth = requireAdminAuth(request);
  if (!auth.ok) {
    return NextResponse.json(
      { success: false, error: auth.error },
      { status: auth.status },
    );
  }

  try {
    const { searchParams } = new URL(request.url);
    const ownerIdFilter = searchParams.get("ownerId") || undefined;
    const sortMode = searchParams.get("sort") || "temperature";

    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const where: Record<string, unknown> = {
      deletedAt: null,
      status: { notIn: TERMINAL_STATUSES },
    };
    if (ownerIdFilter) where.ownerId = ownerIdFilter;

    // Main query: leads + SYSTEM activities + owner
    const leads = await prisma.lead.findMany({
      where,
      include: {
        account: { select: { id: true, name: true, domain: true } },
        source: { select: { name: true } },
        ownerUser: { select: { id: true, name: true, email: true } },
        activities: {
          where: { type: "SYSTEM", createdAt: { gte: thirtyDaysAgo } },
          orderBy: { createdAt: "desc" },
          select: {
            id: true,
            type: true,
            title: true,
            notes: true,
            createdAt: true,
          },
        },
      },
    });

    // Efficient batch query: open tasks for all leads
    const leadIds = leads.map((l) => l.id);
    const openTasks = leadIds.length > 0
      ? await prisma.activity.findMany({
          where: {
            leadId: { in: leadIds },
            type: "TASK",
            completedAt: null,
          },
          orderBy: [{ dueAt: "asc" }, { createdAt: "asc" }],
          select: {
            id: true,
            leadId: true,
            title: true,
            notes: true,
            dueAt: true,
            createdAt: true,
          },
        })
      : [];

    // Group tasks by leadId
    const tasksByLead = new Map<
      string,
      typeof openTasks
    >();
    for (const task of openTasks) {
      const existing = tasksByLead.get(task.leadId) ?? [];
      existing.push(task);
      tasksByLead.set(task.leadId, existing);
    }

    // Enrich each lead
    const now = new Date();
    const enriched = leads.map((lead) => {
      const systemActivities: ActivityInput[] = lead.activities.map((a) => ({
        id: a.id,
        type: a.type,
        title: a.title,
        notes: a.notes,
        createdAt: a.createdAt,
      }));

      const signal = deriveCommercialSignal(systemActivities);
      const temperature = deriveLeadTemperature(signal.signalLevel);
      const sla = deriveHumanSLA(lead.lastHumanActivityAt, lead.createdAt);

      // Tasks
      const leadTasks = tasksByLead.get(lead.id) ?? [];
      const openTasksCount = leadTasks.length;

      let nextTask: NextTaskInfo | null = null;
      if (leadTasks.length > 0) {
        // Already sorted by dueAt asc, createdAt asc
        const t = leadTasks[0];
        const isAutoGenerated = t.notes?.includes("autoGenerated: true") ?? false;
        const metaCategory = isAutoGenerated
          ? t.notes?.match(/meta\.category:\s*(\S+)/)?.[1] ?? null
          : null;
        const metaConfidence = isAutoGenerated
          ? t.notes?.match(/meta\.confidence:\s*(\S+)/)?.[1] ?? null
          : null;

        nextTask = {
          id: t.id,
          title: t.title,
          dueAt: t.dueAt?.toISOString() ?? null,
          createdAt: t.createdAt.toISOString(),
          autoGenerated: isAutoGenerated,
          metaCategory,
          metaConfidence,
        };
      }

      // Is next task overdue?
      const nextTaskOverdue = nextTask?.dueAt
        ? new Date(nextTask.dueAt) < now
        : false;

      return {
        id: lead.id,
        company: lead.account.name,
        domain: lead.account.domain,
        source: lead.source.name,
        status: lead.status,
        score_final: lead.score,
        ownerId: lead.ownerId,
        ownerName: lead.ownerUser?.name ?? null,
        signalLevel: signal.signalLevel,
        temperature,
        reasons: signal.reasons,
        lastSignalAt: signal.lastSignalAt,
        lastSignalCategory: signal.lastSignalCategory,
        lastSignalAgent: signal.lastSignalAgent,
        lastSignalSourceUrl: signal.lastSignalSourceUrl,
        lastSignalConfidence: signal.lastSignalConfidence,
        lastActivityAt: lead.lastActivityAt,
        lastHumanActivityAt: lead.lastHumanActivityAt,
        sla: {
          status: sla.status,
          label: sla.label,
          hoursElapsed: Math.round(sla.hoursElapsed),
        },
        multiSignalCount: systemActivities.length,
        openTasksCount,
        nextTask,
        _nextTaskOverdue: nextTaskOverdue,
      };
    });

    // Sort
    if (sortMode === "taskDue") {
      enriched.sort((a, b) => {
        // 1. Leads with tasks first
        const aHas = a.openTasksCount > 0 ? 0 : 1;
        const bHas = b.openTasksCount > 0 ? 0 : 1;
        if (aHas !== bHas) return aHas - bHas;

        // 2. Overdue tasks first
        const aOver = a._nextTaskOverdue ? 0 : 1;
        const bOver = b._nextTaskOverdue ? 0 : 1;
        if (aOver !== bOver) return aOver - bOver;

        // 3. Soonest dueAt
        const aDue = a.nextTask?.dueAt ? new Date(a.nextTask.dueAt).getTime() : Infinity;
        const bDue = b.nextTask?.dueAt ? new Date(b.nextTask.dueAt).getTime() : Infinity;
        if (aDue !== bDue) return aDue - bDue;

        // 4. Temperature
        const tempDiff = (TEMP_ORDER[a.temperature] ?? 99) - (TEMP_ORDER[b.temperature] ?? 99);
        if (tempDiff !== 0) return tempDiff;

        // 5. Score
        return (b.score_final ?? -1) - (a.score_final ?? -1);
      });
    } else if (sortMode === "sla") {
      enriched.sort((a, b) => {
        const slaDiff = (SLA_ORDER[a.sla.status] ?? 99) - (SLA_ORDER[b.sla.status] ?? 99);
        if (slaDiff !== 0) return slaDiff;
        const tempDiff = (TEMP_ORDER[a.temperature] ?? 99) - (TEMP_ORDER[b.temperature] ?? 99);
        if (tempDiff !== 0) return tempDiff;
        const aSignal = a.lastSignalAt ? new Date(a.lastSignalAt).getTime() : 0;
        const bSignal = b.lastSignalAt ? new Date(b.lastSignalAt).getTime() : 0;
        return bSignal - aSignal;
      });
    } else {
      // Default: temperature → lastSignalAt → score
      enriched.sort((a, b) => {
        const tempDiff = (TEMP_ORDER[a.temperature] ?? 99) - (TEMP_ORDER[b.temperature] ?? 99);
        if (tempDiff !== 0) return tempDiff;
        const aSignal = a.lastSignalAt ? new Date(a.lastSignalAt).getTime() : 0;
        const bSignal = b.lastSignalAt ? new Date(b.lastSignalAt).getTime() : 0;
        if (aSignal !== bSignal) return bSignal - aSignal;
        return (b.score_final ?? -1) - (a.score_final ?? -1);
      });
    }

    return NextResponse.json({
      success: true,
      count: enriched.length,
      items: enriched,
    });
  } catch (error) {
    console.error("[work-queue] Error:", error);
    return NextResponse.json(
      {
        success: false,
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 },
    );
  }
}
