import { NextResponse } from "next/server";
import { requireAdminAuth } from "@/lib/adminAuth";
import prisma from "@/lib/prisma";
import { LeadStatus } from "@prisma/client";
import { parseTaskMeta } from "@/lib/crm/parseTaskMeta";
import { deriveCommercialSignal, type ActivityInput } from "@/lib/crm/deriveCommercialSignal";
import { deriveLeadTemperature } from "@/lib/crm/deriveLeadTemperature";

const TERMINAL_STATUSES: LeadStatus[] = [
  LeadStatus.WON,
  LeadStatus.LOST,
  LeadStatus.DISCARDED,
];

type DueBucket = "OVERDUE" | "TODAY" | "WEEK" | "LATER" | "NONE";

function computeDueBucket(dueAt: Date | null, now: Date): DueBucket {
  if (!dueAt) return "NONE";
  if (dueAt < now) return "OVERDUE";
  const endOfToday = new Date(now);
  endOfToday.setHours(23, 59, 59, 999);
  if (dueAt <= endOfToday) return "TODAY";
  const weekFromNow = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
  if (dueAt <= weekFromNow) return "WEEK";
  return "LATER";
}

/**
 * GET /api/admin/tasks
 *
 * Returns all open TASK activities across non-terminal leads,
 * enriched with lead context and derived signals.
 */
export async function GET(request: Request) {
  const auth = requireAdminAuth(request);
  if (!auth.ok) {
    return NextResponse.json(
      { success: false, error: auth.error },
      { status: auth.status },
    );
  }

  try {
    const now = new Date();
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    // Single efficient query: open tasks with lead + account + source + owner
    const tasks = await prisma.activity.findMany({
      where: {
        type: "TASK",
        completedAt: null,
        lead: {
          deletedAt: null,
          status: { notIn: TERMINAL_STATUSES },
        },
      },
      orderBy: [{ dueAt: "asc" }, { createdAt: "desc" }],
      include: {
        lead: {
          include: {
            account: { select: { name: true, domain: true } },
            source: { select: { name: true } },
            ownerUser: { select: { id: true, name: true, email: true } },
            activities: {
              where: { type: "SYSTEM", createdAt: { gte: thirtyDaysAgo } },
              orderBy: { createdAt: "desc" },
              select: { id: true, type: true, title: true, notes: true, createdAt: true },
            },
          },
        },
        createdBy: { select: { id: true, name: true } },
      },
    });

    const items = tasks.map((task) => {
      const meta = parseTaskMeta(task.notes);
      const dueBucket = computeDueBucket(task.dueAt, now);
      const isOverdue = task.dueAt ? task.dueAt < now : false;

      // Derive signal for the lead
      const systemActivities: ActivityInput[] = task.lead.activities.map((a) => ({
        id: a.id,
        type: a.type,
        title: a.title,
        notes: a.notes,
        createdAt: a.createdAt,
      }));
      const signal = deriveCommercialSignal(systemActivities);
      const temperature = deriveLeadTemperature(signal.signalLevel);

      return {
        task: {
          id: task.id,
          title: task.title,
          dueAt: task.dueAt?.toISOString() ?? null,
          createdAt: task.createdAt.toISOString(),
          autoGenerated: meta.autoGenerated,
          metaCategory: meta.category,
          metaConfidence: meta.confidence,
        },
        lead: {
          id: task.lead.id,
          status: task.lead.status,
          score_final: task.lead.score,
          company: task.lead.account.name,
          domain: task.lead.account.domain,
          source: task.lead.source.name,
          temperature,
          signalLevel: signal.signalLevel,
          ownerId: task.lead.ownerId,
          ownerName: task.lead.ownerUser?.name ?? null,
        },
        isOverdue,
        dueBucket,
      };
    });

    // Sort: overdue first → due soonest → createdAt desc
    items.sort((a, b) => {
      const bucketOrder: Record<DueBucket, number> = {
        OVERDUE: 0,
        TODAY: 1,
        WEEK: 2,
        LATER: 3,
        NONE: 4,
      };
      const bucketDiff = bucketOrder[a.dueBucket] - bucketOrder[b.dueBucket];
      if (bucketDiff !== 0) return bucketDiff;

      const aDue = a.task.dueAt ? new Date(a.task.dueAt).getTime() : Infinity;
      const bDue = b.task.dueAt ? new Date(b.task.dueAt).getTime() : Infinity;
      if (aDue !== bDue) return aDue - bDue;

      return new Date(b.task.createdAt).getTime() - new Date(a.task.createdAt).getTime();
    });

    return NextResponse.json({
      success: true,
      count: items.length,
      items,
    });
  } catch (error) {
    console.error("[tasks-inbox] Error:", error);
    return NextResponse.json(
      { success: false, error: "Internal server error" },
      { status: 500 },
    );
  }
}
